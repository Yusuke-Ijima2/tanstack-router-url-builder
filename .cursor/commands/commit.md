---
description: Gitå·®åˆ†ã‚’åˆ†æã—ã¦é©åˆ‡ãªç²’åº¦ã§ã‚³ãƒŸãƒƒãƒˆã‚’ä½œæˆï¼ˆAIãŒè³ªå•ã—ã¦Whyã‚’å¼•ãå‡ºã™ï¼‰
---

## Execution Steps

1. Analyze changes with `git status` and `git diff`
2. Report any potential issues or concerns in the diff and do not commit
3. Group commits based on the following criteria:
   - 1 commit = 1 logical change
   - Dependent changes in the same commit
4. Stage changes with appropriate granularity (`git add`)
5. Generate questions about the staged changes to understand Why (reason for the change)
   - Your primary focus MUST be on the STAGED CHANGES (the diff) AND session history
   - First, analyze the staged changes AND session history to understand what context is already available
   - Only ask questions about "why" that cannot be inferred from the session history
   - If the "why" can be understood from the session history, do not ask questions and proceed to generate the commit message
   - If questions are needed, generate all necessary questions at once (the number of questions may vary depending on the complexity of the changes and how much context is available in the session)
   - Present all questions together to the user at once
   - Focus on the "why" and "intent", not just the "what"
   - Avoid generic questions like "What does this change do?"
   - Examples of GOOD questions (when you see specific changes in the diff):
     - If you see a timeout value change: "Why was the timeout increased from 3 to 5 seconds?"
     - If you see a nil check added: "What edge case or error scenario does this nil check handle?"
     - If you see code refactored: "Is this refactor part of a larger cleanup effort, or was there a specific issue that prompted it?"
     - If you see a test split: "Why did you decide to split this test into multiple smaller tests?"
   - Examples of BAD questions (avoid these):
     - "Did you update the file?" (obvious from diff)
     - "What is the new value of X?" (can be seen in diff)
     - "What does this change do?" (too generic, focus on "why")
6. If questions were asked, collect answers from the user for all questions
7. Complete the commit message based on the answers (and session history)
8. ALWAYS ask the user for confirmation before executing the commit
9. After user confirms, execute the commit
10. If there are remaining unstaged changes, return to step 4

## Commit Message Format

```
<emoji> <prefix>: <subject>

[body: explain the reason for the change (generated based on answers)]
```

**<emoji> <prefix> List:**

- âœ¨ feat: introduce new features
- ğŸ› fix: fix bugs
- âš¡ï¸ perf: improve performance
- â™»ï¸ refactor: refactor code
- ğŸ”¥ remove: remove code or files
- ğŸ’„ style: add or update UI and style files
- ğŸš¸ ux: improve user experience/usability
- â™¿ï¸ a11y: improve accessibility
- ğŸ“ docs: add or update documentation
- ğŸ’¡ comment: add or update comments in source code
- âœï¸ typo: fix typos
- ğŸ¤¡ mock: create mocks
- ğŸ·ï¸ types: add or update types

**Rules:**

- subject: concisely describe the change within 50 characters (generated by AI)
- body: explain the reason ("why") for the change in detail (**generated by AI based on answers and session history**). Focus on narrative and context, not just describing what's in the diff. Think of the signal:noise ratio - you want the reader to truly understand the 'why' behind the changes
- **IMPORTANT: Write each sentence in the body on a separate line (one sentence per line)**
- **ALWAYS ask the user for confirmation before executing the commit**
- **After executing this command, return to normal mode and do not automatically commit until the user explicitly runs `/commit`**
- **Write all commit messages in Japanese.**
